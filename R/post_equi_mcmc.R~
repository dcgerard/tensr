convert_cov <- function(equi_mcmc_obj) {
    ## This function returns posterior draws of each component
    ## covariance matrix.
    ## equi_mcmc_obj: output from equi_mcmc()
    n <- length(equi_mcmc_obj[[1]])
    p <- rep(NA, length = n)
    ## convert to posterior draws of variance
    sig2_post <- equi_mcmc_obj[[2]] ^ 2


    chol_half_list <- list()
    for (mode_index in 1:n) {
        p[mode_index] <- dim(equi_mcmc_obj[[1]][[mode_index]])[1]
        chol_half_list[[mode_index]] <-
          array(apply(equi_mcmc_obj[[1]][[mode_index]], 3,
                      backsolve, upper.tri = FALSE, x = diag(p[mode_index])),
                dim = dim(equi_mcmc_obj[[1]][[mode_index]]))
    }
    cov_list <- list()
    for (mode_index in 1:n) {
        cov_list[[mode_index]] <-
          array(apply(chol_half_list[[mode_index]], 3, tcrossprod),
                dim = dim(equi_mcmc_obj[[1]][[mode_index]]))
    }
    return(list(cov_post = cov_list, sig2_post = sig2_post))
}



get_equi_bayes <- function(psi_inv, sigma, burnin = NULL) {
    ## get's the bayes rule using multiway Stein's loss returns
    ## the cholesky square root of Bayes rule.  input is lists of arrays
    ## as input for psi.inv
    itermax <- length(sigma)
    if (is.null(burnin)) {
        burnin <- round(itermax * 0.25)
    }
    p <- sapply(psi_inv, dim)[1, ]
    n <- length(p)
    Sig_hat_list <- vector(mode = "list", length = n)
    ## initialize
    for (mode_index in 1:n) {
        Sig_hat_list[[mode_index]] <- t(psi_inv[[mode_index]][, , burnin]) %*%
          psi_inv[[mode_index]][, , burnin] / sigma[burnin] ^ 2
    }
    ## Now sum over all the iterations
    for (iter_index in (burnin + 1):itermax) {
        for (mode_index in 1:n) {
            Sig_hat_list[[mode_index]] <- Sig_hat_list[[mode_index]]
            + t(psi_inv[[mode_index]][, , iter_index]) %*%
              psi_inv[[mode_index]][, , iter_index] / sigma[iter_index] ^ 2
        }
    }
    for (mode_index in 1:n) {
        ## take inverse of average to get estimator
        Sig_hat_list[[mode_index]] <-
          solve(Sig_hat_list[[mode_index]] / (itermax - burnin + 1))
    }

    ## set the determinant to 1 and find scale estimate
    det_sig <- rep(NA, length = n)
    B_list <- vector(mode = "list", length = n)
    b_sum <- 0
    for (mode_index in 1:n) {
        det_sig[mode_index] <- det(Sig_hat_list[[mode_index]])
        B_list[[mode_index]] <- t(chol(Sig_hat_list[[mode_index]]))
        B_list[[mode_index]] <-
          B_list[[mode_index]] / det_sig[mode_index] ^ (1 / (2 * p[mode_index]))
        b_sum <- b_sum + det_sig[mode_index] ^ (1 / -p[mode_index])
    }
    b_hat <- n / b_sum
    return(list(B = B_list, b = sqrt(b_hat)))
}

random_ortho <- function(p) {
    ## generates a list of orthogonal matrices drawn from Haar distribution
    n <- length(p)
    ortho_list <- list()
    for (index in 1:n) {
        x_temp <- matrix(rnorm(p[index] ^ 2), ncol = p[index], nrow = p[index])
        ortho_list[[index]] <- solve(mhalf(x_temp %*% t(x_temp))) %*% x_temp
    }
    return(ortho_list)
}

multiway_takemura <- function(X, ortho_max = 2, mcmc_itermax = 1000,
                              start_identity = FALSE, print_mcmc = FALSE) {
    ## this function will return a truncated multiway Takemura's estimator.
    ## Truncated b/c not actually averaging over whole Haar
    ## p.m. for orthogonal group.
    ## ortho_max = number of estimators to 'average' it returns the covariance
    ## estimate, not the square root matrix of the covariance estimate.
    p <- dim(X)
    n <- length(p)
    for (ortho_index in 1:ortho_max) {
        ## transform orthogonally along each mode
        ortho_list <- random_ortho(p)
        X_ortho <- atrans(X, ortho_list)

        bayes_fit <-
          equi_mcmc(X_ortho, itermax = mcmc_itermax, start_identity = TRUE)
        bayes_rule_ortho <-
          get_equi_bayes(bayes_fit$Phi_inv, bayes_fit$sigma)

        ## orthogonallize back
        bayes_rule_back <- list()
        bayes_rule_back[[1]] <- list()
        bayes_rule_back[[2]] <- bayes_rule_ortho$b
        for (bayes_index in 1:n) {
            temp_bayes_rule <- t(ortho_list[[bayes_index]]) %*%
              bayes_rule_ortho$B[[bayes_index]]
            bayes_rule_back[[1]][[bayes_index]] <-
              temp_bayes_rule %*% t(temp_bayes_rule)
        }

        if (ortho_index == 1) {
            bayes_rule <- bayes_rule_back
        } else {
            ## now weighted average to get final bayes rule, but do the
             ## averaging on the trace scale, then scale back down to
             ## determinant scale
            bayes_rule[[2]] <- bayes_rule_back[[2]] / ortho_index +
              bayes_rule[[2]] * (ortho_index - 1) / ortho_index
            names(bayes_rule) <- c("B", "b")
            for (bayes_index in 1:n) {
                back_temp <- bayes_rule_back[[1]][[bayes_index]]
                back_temp <- back_temp / tr(back_temp)
                bayes_prev_temp <- bayes_rule[[1]][[bayes_index]] /
                  tr(bayes_rule[[1]][[bayes_index]])
                combo_temp <- back_temp / ortho_index +
                  (ortho_index - 1) / ortho_index * bayes_prev_temp
                bayes_rule[[1]][[bayes_index]] <-
                  combo_temp / det(combo_temp) ^ (1 / p[bayes_index])
            }
        }
        if (print_mcmc) {
            cat("Number of averagings = ", ortho_index, "\n")
        }
    }
    return(bayes_rule)
}
